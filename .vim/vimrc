set nocompatible
let mapleader='\'
let maplocalleader='\'
nnoremap ,, ,

set vi=<0,'0,/16,f1,h history=100
set bs=2 ts=2 sw=2 expandtab
set lazyredraw modeline modelines=3
set nowrap noshowmode nohlsearch nobackup nowritebackup
set ignorecase smartcase autoindent
set foldmethod=marker foldnestmax=3 foldminlines=3
set wildmode=longest,list
set bo=all
set mouse=v

set number scl=number
set shortmess+=c
set ttimeoutlen=50 updatetime=800
filetype plugin on

" --- COC ---

fun! s:check_back_space() abort
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~# '\s'
endfun

fun! s:show_documentation()
  if (index(['vim','help'], &filetype) >= 0)
    execute 'h '.expand('<cword>')
  elseif (coc#rpc#ready())
    call CocActionAsync('doHover')
  else
    execute '!' . &keywordprg . " " . expand('<cword>')
  endif
endfun

inoremap <silent><expr> <TAB>
       \ pumvisible() ? "\<C-n>" :
       \ <SID>check_back_space() ? "\<TAB>" :
       \ coc#refresh()
inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"

nnoremap yY :%yank <c-r>=v:register<cr><cr>
nnoremap dD :%delete <c-r>=v:register<cr><cr>
nnoremap <silent> [q :cprev<CR>
nnoremap <silent> ]q :cnext<CR>
nnoremap <silent> K :call <SID>show_documentation()<CR>
nmap <silent> [e <Plug>(coc-diagnostic-prev)
nmap <silent> ]e <Plug>(coc-diagnostic-next)
nmap <silent> ,jd <Plug>(coc-definition)
nmap <silent> ,wd :call CocAction('jumpDefinition', 'split')<CR>
nmap <silent> ,jt <Plug>(coc-type-definition)
nmap <silent> ,ji <Plug>(coc-implementation)
nmap <silent> ,jr <Plug>(coc-references)

" --- Mappings ---

fun! s:buffer_dir()
  return expand(&ft == 'dirvish' ? '%' : '%:h')
endfun

fun! s:wipe_buffers()
  let tablist = []
  for i in range(tabpagenr('$'))
    call extend(tablist, tabpagebuflist(i + 1))
  endfor

  let bc = 0
  for i in range(1, bufnr('$'))
    " bufno exists AND isn't modified AND isn't in the list of buffers open in windows and tabs
    if bufexists(i) && !getbufvar(i,"&mod") && index(tablist, i) == -1
      silent exec 'bwipeout' i
      let bc = bc+1
    endif
  endfor
  echomsg bc . ' buffer(s) wiped out.'
endfun

fun! s:fit_window_to_buffer()
  let bottom = line('$')
  let size = &lines
  let result = 0
  let i = 0
  while result < size && i < bottom
    let result += 1
    if foldclosed(i) > 0
      let i = foldclosedend(i)+1
    else
      let i += 1
    endif
  endw
  exe 'resize '.result
endfun

command! -nargs=? -complete=dir SDirvish split | silent Dirvish <args>

nnoremap <silent>,s :sp %:h<CR>
nnoremap <silent>,S :sp .<CR>
nnoremap <silent>,e :e %:h<CR>
nnoremap <silent>,E :e .<CR>
nnoremap <silent>,~ :Dirvish ~<CR>
nnoremap <silent>,b :Buffers<CR>
nnoremap <silent>,f :Files<CR>
nnoremap <silent>,g :GFiles?<CR>
nnoremap <silent>,G :GFiles<CR>
nnoremap ,/ :BLines<Space>
nnoremap ,? :Lines<Space>
nnoremap ,n :set invnumber<CR>
nnoremap ,v :set invpaste<CR>
nnoremap ,m :set invwrap invlinebreak<CR>
nnoremap ,H :set invhlsearch<CR>
nnoremap <silent>,( :RainbowToggle<CR>
nnoremap <silent><C-W>S :call <SID>fit_window_to_buffer()<CR>gg''
nnoremap <silent>du :diffupdate<CR>
nnoremap <silent>dP :.diffput<CR>
nnoremap <silent>,d :CocFzfList diagnostics --current-buf<CR>
nnoremap <silent>,D :CocFzfList diagnostics<CR>
nnoremap <silent>,o :CocFzfList outline<CR>

nnoremap <silent>,i :-tabnew<CR>
nnoremap <silent>,a :tabnew<CR>
nnoremap <silent>,I :0tabnew<CR>
nnoremap <silent>,A :$tabnew<CR>
" The following two are the same thing, but whatever.
nnoremap <silent>,0 :tabfirst<CR>
nnoremap <silent>,1 :tabn 1<CR>
nnoremap <silent>,2 :tabn 2<CR>
nnoremap <silent>,3 :tabn 3<CR>
nnoremap <silent>,4 :tabn 4<CR>
nnoremap <silent>,$ :tablast<CR>
nnoremap ,h gT
nnoremap ,l gt
nnoremap <silent>,<Tab> g<Tab>
nnoremap <silent>,W :call <SID>wipe_buffers()<CR>
nnoremap ,r :Rg<Space>
nnoremap ,c :tcd<Space>
nnoremap ,C :tcd ../
nnoremap <silent>,. :execute("tcd ".<SID>buffer_dir())<CR>
nnoremap <silent>,p :echo "Current path:" getcwd()<CR>

xmap i= <Plug>(indent-object_linewise-none)
omap i= <Plug>(indent-object_linewise-none)
xmap a= <Plug>(indent-object_linewise-end)
omap a= <Plug>(indent-object_linewise-end)
nmap <silent> [= <Plug>(indent-start)
nmap <silent> ]= <Plug>(indent-end)
omap <silent> [= <Plug>(indent-line-start)
omap <silent> ]= <Plug>(indent-line-end)
vmap <silent> [= <Plug>(indent-visual-start)
vmap <silent> ]= <Plug>(indent-visual-end)

nnoremap <Up> <C-W>+
nnoremap <Down> <C-W>-
nnoremap <Left> <C-W><
nnoremap <Right> <C-W>>
nnoremap <C-W>" :term<CR>
nnoremap <C-W>% :vert rightb term<CR>
tnoremap <C-B>" <C-W>:term<CR>
tnoremap <C-B>% <C-W>:vert rightb term<CR>

vnoremap ,: :normal<Space>

" --- Looks ---

let &t_SI = "\e[5 q"
let &t_EI = "\e[2 q" 
let &t_SR = "\e[4 q"
let &t_ER = "\e[2 q"
syn on

set ruler ls=2 bg=dark
set fillchars=vert:â”‚,fold:\  " That's an escaped space.

" --- Autocmd ---

if exists('$TMUX')
  let g:fzf_layout = { 'tmux': '-p90%,60%' }
  let g:fzf_preview_window=['right:60%', 'ctrl-/']
else
  let g:fzf_layout = { 'window': { 'width': 0.9, 'height': 0.6 } }

  fun! s:resized()
    if &co > 159
      let g:fzf_preview_window=['right:60%', 'ctrl-/']
    else
      let g:fzf_preview_window=['up:40%', 'ctrl-/']
    endif
  endfun

  call s:resized()
endif

augroup vimrc
  autocmd!
  au BufNewFile,BufRead * set fo-=o
  if !exists('$TMUX')
    au VimResized * call s:resized()
  endif
augroup END

" --- Config ---

let g:paredit_leader = '\'
let g:rainbow_active = 0
let g:rainbow_conf = {
      \ 'ctermfgs': [9, 208, 11, 10, 14, 12, 13],
      \ 'separately': {
      \   'elixir': {
      \     'parentheses_options': 'containedin=elixirMap' }}}

if !empty($VIM_COLORSCHEME)
  execute 'colorscheme ' . $VIM_COLORSCHEME
elseif has('gui_running')
  colorscheme gui_gruvbox
else
  colorscheme almost_ansi
endif

if has('macunix')
  set rtp+=/opt/homebrew/opt/fzf
endif

if has('nvim')
  set pp^=~/.vim/nvim
  set dir^=~/.vim/nvim/swap
else
  set pp^=~/.vim/vim8
  set dir^=~/.vim/vim8/swap
endif

nnoremap q: :q
nnoremap q<Tab> q:
